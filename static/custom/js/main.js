// GLOBAL VARIABLES
let parsedPriceData;
//let organizedTickerData; // This was moved to priceData.js
let allTickers;
let numStocksSelected = 0;
let availableColors = ['cerulean', 'orange', 'pink', 'white', 'magenta'];
const keywordInput = document.getElementById('keywordInput');
const keywordList = document.getElementById('keywordList');
//assigning the keyword list in d3 as well for the .append() function
let kwList = d3.select('#keywordList');
let keywordItems = document.querySelectorAll('.keywordItem');
let plotDiv = document.getElementById('price-plot');
let wordDiv = document.getElementById('word-cloud');
let currentTickerArr = [];

/* ------------- *
 *   FUNCTIONS
 * ------------- */

/**
 * _Code from user Bergi on StackOverflow_
 * _https://stackoverflow.com/questions/11786995/create-object-on-the-fly-from-csv_
 * @param {*} input string (raw CSV text)
 * @returns a 2-dimensional Array containing rows of CSV data.
 */
function parsePriceCSV(input) {
    let rows = input.split(/\r?\n/);
    let keys = rows.shift().split(",");
    return rows.map(function(row) {
        return row.split(",").reduce(function(oneRow, val, i) {
            oneRow[keys[i]] = val;
            return oneRow;
        }, {});
    });
}

// TODO ADD BUTTON TO REMOVE ALL SELECTED STOCKS

/**
 * _Generated by ChatGPT 3.5 and tweaked to our purposes._  
 * @param {*} inputArr input array, assumed csv
 * @returns an Object formatted with collapsing {ticker: {(ticker, string): {priceHistory: {(month, integer): {data...}}}}}. See comment below docket.
 */
/*
 * Ticker:
 *  ┕ priceHistory:
 *      ┝ 1: (month)
 *      .   ┝ open: price
 *      .   ┝ close: price
 *      .   ┕ ...
 *      ┝ 2:
 *      ┕ ...
 */
function convertData(inputArr) {
    let output = {};
    
    inputArr.forEach(item => {
        const {ticker, date, ...rest } = item;
        
        if (!output[ticker]) {
            output[ticker] = {
                priceHistory: {}
            };
        };
        
        //filter out just the month from the date, parse as integer
        output[ticker].priceHistory[parseInt(date)] = rest;
    });
    
    return output;
}

function genPriceTraceArray(tickerArr, dataPoint='close') {
    let traceList = [];

    //creating this variable to enforce the 5-trace maximum
    let tickerListTrunc = tickerArr.slice(0, 5);

    //iterate through ticker list
    for (let i=0; i < tickerListTrunc.length; i++) {
        //assign price history for ticker to variable
        let tickerData = organizedTickerData[tickerListTrunc[i]].priceHistory;
        months = [];
        prices = [];

        // Add months from tickerData to add both all available months 
        // and values for said months according to the specified dataPoint
        for(let key in tickerData) {
            months.push(key);
            prices.push(tickerData[key][`${dataPoint}`]);
        };

        // I'd like to make it so that a ticker remembers its color but
        // it should be fine just directly referencing the availableColors array for now

        let trace = {
            x: months,
            y: prices,
            mode: 'lines',
            name: tickerListTrunc[i],
            line: {color: availableColors[i]}
        };

        traceList.push(trace);
    };

    return traceList;
}

//updates active ticker list by querying the current list for selected tickers
function refreshTracesAndPlot(priceDataPoint='close', wordCloudDataSrc='news') {
    let oldTickerArr = currentTickerArr;
    let selectedTickerLiItems = document.querySelectorAll('li.selected');
    currentTickerArr = [];

    if (selectedTickerLiItems){
        for (let i = 0;i < selectedTickerLiItems.length; i++){
            currentTickerArr.push(selectedTickerLiItems[i].textContent);
        }
    }

    //console.log(currentTickerArr);

    //only re-plot stocks if something actually changed
    if (oldTickerArr != currentTickerArr) {
        plotStocks(genPriceTraceArray(currentTickerArr));
    }

}

function clearSelectedStocks() {
    let selectedTickerLiItems = document.querySelectorAll('li.selected');
    selectedTickerLiItems.forEach(function(li) {
        li.classList.remove('selected');
    });
    numStocksSelected = 0;
    keywordList.classList.remove('full');
    refreshTracesAndPlot();
}

/* --------------- *
 * EVENT LISTENERS
 * --------------- */

keywordInput.addEventListener('input', function() {
    let filter = keywordInput.value.trim().toLowerCase(); // trim() to remove leading/trailing spaces
    console.log(keywordItems);
    keywordItems.forEach(item => {
        let text = item.textContent.toLowerCase();
        if (text.includes(filter)) {
            item.style.display = 'block';
        } else {
            item.style.display = 'none';
        }
    });
});

// Event listener to handle keyword selection
keywordList.addEventListener('click', function(event) {
    if (event.target.classList.contains('keywordItem')) {
        const selectedKeyword = event.target.textContent;
        //console.log('Selected keyword:', selectedKeyword);

        //if it does NOT contain 'selected'
        if (!event.target.classList.contains('selected')) {
            if (numStocksSelected < 5) {
                // Add the 'selected' class to the clicked item
                event.target.classList.add('selected');
                numStocksSelected++;
            }
        } else {
            event.target.classList.remove('selected');
            numStocksSelected--;
        }

        if (numStocksSelected >= 5) {
            keywordList.classList.add('full');
        } else {
            keywordList.classList.remove('full');
        }

        refreshTracesAndPlot();
    }
});

//resize plot if window size changes
window.addEventListener('resize', resizePlot);

/* ------------------ *
 *   INITIALIZATION
 * ------------------ */

allTickers = Object.keys(organizedTickerData);

//add first ticker as a selected stock, set numStocksSelected to reflect
kwList.append("li").classed("keywordItem", true).classed("selected", true).text(allTickers[0]);
numStocksSelected = 1;
//adding the rest of our stock tickers
for(let i=1;i<allTickers.length;i++) {
    kwList.append("li").classed("keywordItem", true).classed("selected", false).text(allTickers[i]);
}
keywordItems = document.querySelectorAll('.keywordItem');

WordCloud(document.getElementById('word-cloud'), { 
    list: [['test', 1, -1], ['test2', 10, 1], ['lllllll', 2, 0]],
    gridSize: Math.round(16 * wordDiv.clientWidth / 1024),
    weightFactor: function (size) {
        //return Math.pow(size, 2.3) * wordDiv.clientWidth / 1024;
        return Math.sqrt(size) * 20;
    },
    fontFamily: 'Times, serif',
    color: function (word, weight, value) {
        return (value > 0.1) ? '#22f022' : (value < -0.1) ? '#f02222' : '#888';
    },
    rotateRatio: 0.5,
    rotationSteps: 2,
    backgroundColor: '#111' 
});

refreshTracesAndPlot();


// grab stock data and process it
// EVERYTHING SHOULD BE IN THE SECOND .then() SO THAT IT GETS EXECUTED IN ORDER
// fetch('Resourses/stockdata.csv')
//     .then(response => response.text())
//     .then(function(table) {
        
//         //convert csv array to a more usable JavaScript Object
//         //THE DATA WAS ORIGINALLY CLEANED UP HERE, BUT IT IS NO LONGER NECESSARY
//         //JSON SAVED DIRECTLY TO priceData.js
//         //organizedTickerData = convertData(parsePriceCSV(table));

//         allTickers = Object.keys(organizedTickerData);

//         // console.log("tickers: ", tickers);
//         // console.log(organizedTickerData);
        
//         //assigning the keyword list
//         let kwList = d3.select('#keywordList');
        
//         //add first ticker as a selected stock, set numStocksSelected to reflect
//         kwList.append("li").classed("keywordItem", true).classed("selected", true).text(allTickers[0]);
//         numStocksSelected = 1;
//         //adding the rest of our stock tickers
//         for(let i=1;i<allTickers.length;i++) {
//             kwList.append("li").classed("keywordItem", true).classed("selected", false).text(allTickers[i]);
//         }
//         keywordItems = document.querySelectorAll('.keywordItem');

//         refreshTracesAndPlot();

//     }).catch(err => console.log(err));

