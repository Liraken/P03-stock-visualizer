window.clearSelectedStocks = clearSelectedStocks;

// VARIABLES
// let parsedPriceData;
// let organizedTickerData; // This was moved to priceData.js
let allTickers;
let numStocksSelected = 0;
let availableColors = ['cerulean', 'orange', 'pink', 'white', 'magenta'];
const keywordInput = document.getElementById('keywordInput');
const keywordList = document.getElementById('keywordList');
//assigning the keyword list in d3 as well for the .append() function
let kwList = d3.select('#keywordList');
let keywordItems = document.querySelectorAll('.keywordItem');
let plotDiv = document.getElementById('price-plot');
let wordDiv = document.getElementById('word-cloud');
let currentTickerArr = [];

//this will be controllable via radio button to toggle between news and shareholder letters
let keywordSource = 'news';

/* ------------- *
 *   FUNCTIONS
 * ------------- */

/**
 * _Code from user Bergi on StackOverflow_
 * _https://stackoverflow.com/questions/11786995/create-object-on-the-fly-from-csv_
 * @param {*} input string (raw CSV text)
 * @returns a 2-dimensional Array containing rows of CSV data.
 */
function parsePriceCSV(input) {
    let rows = input.split(/\r?\n/);
    let keys = rows.shift().split(",");
    return rows.map(function(row) {
        return row.split(",").reduce(function(oneRow, val, i) {
            oneRow[keys[i]] = val;
            return oneRow;
        }, {});
    });
}

// TODO ADD BUTTON TO REMOVE ALL SELECTED STOCKS

/**
 * _Generated by ChatGPT 3.5 and tweaked to our purposes._  
 * @param {*} inputArr input array, assumed csv
 * @returns an Object formatted with collapsing {ticker: {(ticker, string): {priceHistory: {(month, integer): {data...}}}}}. See comment below docket.
 */
/*
 * Ticker:
 *  ┕ priceHistory:
 *      ┝ 1: (month)
 *      .   ┝ open: price
 *      .   ┝ close: price
 *      .   ┕ ...
 *      ┝ 2:
 *      ┕ ...
 */
function convertData(inputArr) {
    let output = {};
    
    inputArr.forEach(item => {
        const {ticker, date, ...rest } = item;
        
        if (!output[ticker]) {
            output[ticker] = {
                priceHistory: {}
            };
        };
        
        
        output[ticker].priceHistory[date] = rest;
    });
    
    return output;
}

function genPriceTraceArray(tickerArr, dataPoint='close') {
    let traceList = [];

    //creating this variable to enforce the 5-trace maximum
    let tickerListTrunc = tickerArr.slice(0, 5);

    //iterate through ticker list
    for (let i=0; i < tickerListTrunc.length; i++) {
        //assign price history for ticker to variable
        let tickerData = organizedTickerData[tickerListTrunc[i]].priceHistory;
        let months = [];
        let prices = [];

        // Add months from tickerData to add both all available months 
        // and values for said months according to the specified dataPoint
        for(let key in tickerData) {
            months.push(key);
            prices.push(tickerData[key][`${dataPoint}`]);
        };

        // I'd like to make it so that a ticker remembers its color but
        // it should be fine just directly referencing the availableColors array for now
        let trace = {
            x: months,
            y: prices,
            mode: 'lines',
            name: tickerListTrunc[i],
            line: {color: availableColors[i]}
        };

        traceList.push(trace);
    };

    return traceList;
}

function mapValueToColor(value) {
    // Define the minimum and maximum values for mapping
    const minValue = -10;
    const maxValue = 10;
    
    // Map the value to a range between 0 and 1
    const mappedValue = ((value - minValue) / (maxValue - minValue) - 0.5) * 40;
    //console.log(value, mappedValue);

    // Define the hue for green (120 degrees) and red (0 degrees)
    const greenHue = 140;
    const redHue = 0;

    // Calculate the hue based on the mapped value
    // Green if above 0, red if below 0
    let hue = mappedValue > 0 ? greenHue : redHue;

    // Set saturation and lightness to a constant value
    const saturation = Math.pow(Math.abs(mappedValue), 2.4) * 12;
    const lightness = 50;

    const color = `hsl(${hue}, ${saturation}%, ${lightness}%)`;

    return color;
}

//generated by chatgpt for the genWordCloud() below
// Function to check if the first item is present
function isFirstItemPresent(array, target) {
    // Iterate over each inner array
    for (let innerArray of array) {
        // Check if the first item of the inner array matches the target
        if (innerArray[0] === target) {
            return array.indexOf(innerArray); // If found, return true
        }
    }
    return false; // If not found, return false
}


function clearCloud() {
    //refresh word cloud div so we get accurate sizes
    wordDiv = document.getElementById('word-cloud');

    //Delete existing svgs
    while (wordDiv.firstChild) {
        wordDiv.removeChild(wordDiv.firstChild);
    }
}

//  WORD CLOUD
// ------------
//create and draw word cloud
function genWordCloud(tickerArr) {
    //creating this variable to enforce the 5-trace maximum
    //I'd like to make DRY code but I don't have time right now
    let tickerListTrunc = tickerArr.slice(0, 5);
    
    let finalWordArray = [];
    //iterate through ticker list
    for(let i=0; i < tickerListTrunc.length; i++) {
        let tickerWords = wordsAnalysisData[tickerListTrunc[i]][keywordSource].keywords;
        // .map(innerArray => {
        //     return innerArray.map(item => {
        //         // Scale the second item by whatever factor we decide on because I don't want to type it here twice constantly to make the commend match the code
        //         return (innerArray.indexOf(item) === 1) ? item * 1 : item;
        //     });
        // });
        
        //console.log(tickerWords);
        for(let j=0;j<tickerWords.length;j++) {
            let firstItemPres = isFirstItemPresent(finalWordArray, tickerWords[j][0]);
            if(firstItemPres != false) {
                // Add word values together if item is present in list and has returned an array index
                // (Added a size adjustment factor since it shows up more than once)
                finalWordArray[firstItemPres][tickerWords[j][0]].size += Math.pow((Math.abs(tickerWords[j][1]), 2.1) + 20);

            } else {
                // Add word and value from tickerWords to list since it does not already exist
                finalWordArray.push({text: tickerWords[j][0], size: (Math.sqrt(Math.abs(tickerWords[j][1]) * 250) + 15), colorValue: mapValueToColor(tickerWords[j][1])});
            }
        }   
    }

    //console.log(finalWordArray);
    clearCloud();

    cloudLayout = d3.layout.cloud()
        .size([wordDiv.clientWidth, wordDiv.clientHeight]) // Size of the word cloud area
        .words(finalWordArray)
        .padding(5)
        .rotate(function() { return ~~(Math.random() * 2) * 90; }) // Random rotation
        .font("Georgia")
        .fontSize(function(d) { return d.size; }) // Font size based on size attribute
        .on("end", draw);

    cloudLayout.start();

}

//Generated by ChatGPT
function arraysContainSameItems(arr1, arr2) {
    // Check if both arrays have the same length
    if (arr1.length !== arr2.length) {
        return false;
    }

    // Sort both arrays
    const sortedArr1 = arr1.slice().sort();
    const sortedArr2 = arr2.slice().sort();

    // Compare sorted arrays element by element
    for (let i = 0; i < sortedArr1.length; i++) {
        if (sortedArr1[i] !== sortedArr2[i]) {
            return false;
        }
    }

    // If all elements match, arrays contain the same items
    return true;
}

//updates active ticker list by querying the current list for selected tickers
function refreshTracesAndPlot(priceDataPoint='close', wordCloudDataSrc='news') {
    let oldTickerArr = currentTickerArr;
    let selectedTickerLiItems = document.querySelectorAll('li.selected');
    currentTickerArr = [];

    //check that the query selector did not return null
    if (selectedTickerLiItems){
        //iterate over tickers
        for (let i = 0;i < selectedTickerLiItems.length; i++){
            //check if the ticker can be found in the old ticker array
            //and only push our new item if it's not present
            currentTickerArr.push(selectedTickerLiItems[i].textContent);
        }
    }

    // console.log(oldTickerArr);
    // console.log(currentTickerArr);

    //only re-plot stocks if something actually changed
    if (!arraysContainSameItems(oldTickerArr, currentTickerArr)) {
        console.log("different ticker arrays!");
        plotStocks(genPriceTraceArray(currentTickerArr));
        genWordCloud(currentTickerArr);
    }
}

function plotStocks(traceArray) {
    //console.log(traceArray);

    let titleStr = '';
    if (traceArray.length > 0) {
        //preloading first ticker name into title string
        titleStr = `Stock Prices in $USD: ${traceArray[0].name}`;
        //iterating through rest of ticker names, adding them with comma separators
        for(let i = 1; i < traceArray.length; i++) {
            titleStr = titleStr + ", " + `${traceArray[i].name}`;
        };
    } else {
        titleStr = 'Select one or more stock tickers(s) to see plot!'
    }

    //console.log(titleStr);

    let layout = {
        dragmode: 'zoom',
        //selectdirection: 'h',
        title: titleStr,
        width: plotDiv.clientWidth,
        height: plotDiv.clientHeight,
        margin: {
            l: 30,
            r: 30,
            t: 90,
            b: 30
        },
        plot_bgcolor: '#111',
        paper_bgcolor: '#111',
        font: { color: '#eee' },
        line: { color: '#eee' },
        xaxis: { gridcolor: '#555' },
        yaxis: { gridcolor: '#555' }
    };

    Plotly.newPlot("price-plot", traceArray, layout);
}

export function clearSelectedStocks() {
    let selectedTickerLiItems = document.querySelectorAll('li.selected');
    selectedTickerLiItems.forEach(function(li) {
        li.classList.remove('selected');
    });
    numStocksSelected = 0;
    keywordList.classList.remove('full');
    refreshTracesAndPlot();
}

function resizePlot() {
    let update = {
        width: plotDiv.clientWidth,
        height: plotDiv.clientHeight
    };
    Plotly.relayout("price-plot", update);
    //clearCloud();
    cloudLayout.size([wordDiv.clientWidth, wordDiv.clientHeight]);
}

// Callback function to draw the word cloud
function draw(words) {
    d3.select("#word-cloud").append("svg")
        .attr("width", wordDiv.clientWidth)
        .attr("height", wordDiv.clientHeight)
        .append("g")
        .attr("transform", "translate(" + cloudLayout.size()[0] / 2 + "," + cloudLayout.size()[1] / 2 + ")")
        .selectAll("text")
        .data(words)
        .enter().append("text")
        .style("font-size", function(d) { return d.size + "px"; })
        .style("font-family", "Georgia")
        .style("fill", function(d) { return d.colorValue; })
        .attr("text-anchor", "middle")
        .attr("transform", function(d) {
            return "translate(" + [d.x, d.y] + ")rotate(" + d.rotate + ")";
        })
        .text(function(d) { return d.text; });
}

/* --------------- *
 * EVENT LISTENERS
 * --------------- */

keywordInput.addEventListener('input', function() {
    let filter = keywordInput.value.trim().toLowerCase(); // trim() to remove leading/trailing spaces
    console.log(keywordItems);
    keywordItems.forEach(item => {
        let text = item.textContent.toLowerCase();
        if (text.includes(filter)) {
            item.style.display = 'block';
        } else {
            item.style.display = 'none';
        }
    });
});

// Event listener to handle keyword selection
keywordList.addEventListener('click', function(event) {
    if (event.target.classList.contains('keywordItem')) {
        const selectedKeyword = event.target.textContent;
        //console.log('Selected keyword:', selectedKeyword);

        //if it does NOT contain 'selected'
        if (!event.target.classList.contains('selected')) {
            if (numStocksSelected < 5) {
                // Add the 'selected' class to the clicked item
                event.target.classList.add('selected');
                numStocksSelected++;
            }
        } else {
            event.target.classList.remove('selected');
            numStocksSelected--;
        }

        if (numStocksSelected >= 5) {
            keywordList.classList.add('full');
        } else {
            keywordList.classList.remove('full');
        }

        refreshTracesAndPlot();
    }
});

//resize plot if window size changes
window.addEventListener('resize', resizePlot);

/* ------------------ *
 *   INITIALIZATION
 * ------------------ */

allTickers = Object.keys(organizedTickerData);

//add first ticker as a selected stock, set numStocksSelected to reflect
kwList.append("li").classed("keywordItem", true).classed("selected", true).text(allTickers[0]);
numStocksSelected = 1;
//adding the rest of our stock tickers
for(let i=1;i<allTickers.length;i++) {
    kwList.append("li").classed("keywordItem", true).classed("selected", false).classed("has-letter", false).text(allTickers[i]);
}
keywordItems = document.querySelectorAll('.keywordItem');

console.log(wordsAnalysisData);

//-----------------------------------

let words = [
    {text: "Hello", size: 20},
    {text: "World", size: 40},
    {text: "Lorem", size: 30},
    // Add more words as needed
];

// Configure d3-cloud layout
let cloudLayout = d3.layout.cloud()
    .size([wordDiv.clientWidth, wordDiv.clientHeight]) // Size of the word cloud area
    .words(words)
    .padding(5)
    .rotate(function() { return ~~(Math.random() * 2) * 90; }) // Random rotation
    .font("Georgia")
    .fontSize(function(d) { return d.size; }) // Font size based on size attribute
    .on("end", draw); // Callback function to draw the cloud

// Generate the word cloud layout
cloudLayout.start();

refreshTracesAndPlot();

// // grab stock data and process it
// // EVERYTHING SHOULD BE IN THE SECOND .then() SO THAT IT GETS EXECUTED IN ORDER
// fetch('Resourses/stockdata.csv')
//     .then(response => response.text())
//     .then(function(table) {
        
//         //convert csv array to a more usable JavaScript Object
//         //THE DATA WAS ORIGINALLY CLEANED UP HERE, BUT IT IS NO LONGER NECESSARY
//         //JSON SAVED DIRECTLY TO priceData.js
//         organizedTickerData = convertData(parsePriceCSV(table));

//         allTickers = Object.keys(organizedTickerData);

//         // console.log("tickers: ", tickers);
//         // console.log(organizedTickerData);
        
//         //assigning the keyword list
//         let kwList = d3.select('#keywordList');
        
//         //add first ticker as a selected stock, set numStocksSelected to reflect
//         kwList.append("li").classed("keywordItem", true).classed("selected", true).text(allTickers[0]);
//         numStocksSelected = 1;
//         //adding the rest of our stock tickers
//         for(let i=1;i<allTickers.length;i++) {
//             kwList.append("li").classed("keywordItem", true).classed("selected", false).text(allTickers[i]);
//         }
        
//         keywordItems = document.querySelectorAll('.keywordItem');

//         refreshTracesAndPlot();

//     }).catch(err => console.log(err));

    
