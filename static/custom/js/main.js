// GLOBAL VARIABLES
let parsedPriceData;
//let organizedTickerData; // This was moved to priceData.js
let allTickers;
let numStocksSelected = 0;
let availableColors = ['cerulean', 'orange', 'pink', 'white', 'magenta'];
const keywordInput = document.getElementById('keywordInput');
const keywordList = document.getElementById('keywordList');
//assigning the keyword list in d3 as well for the .append() function
let kwList = d3.select('#keywordList');
let keywordItems = document.querySelectorAll('.keywordItem');
let wordDiv = document.getElementById('word-cloud');
let currentTickerArr = [];

//this will be controllable via radio button to toggle between news and shareholder letters
let keywordSource = 'news';

import {  } from '/static/d3-cloud/d3.layout.cloud.js';

/* ------------- *
 *   FUNCTIONS
 * ------------- */

/**
 * _Code from user Bergi on StackOverflow_
 * _https://stackoverflow.com/questions/11786995/create-object-on-the-fly-from-csv_
 * @param {*} input string (raw CSV text)
 * @returns a 2-dimensional Array containing rows of CSV data.
 */
function parsePriceCSV(input) {
    let rows = input.split(/\r?\n/);
    let keys = rows.shift().split(",");
    return rows.map(function(row) {
        return row.split(",").reduce(function(oneRow, val, i) {
            oneRow[keys[i]] = val;
            return oneRow;
        }, {});
    });
}

// TODO ADD BUTTON TO REMOVE ALL SELECTED STOCKS

/**
 * _Generated by ChatGPT 3.5 and tweaked to our purposes._  
 * @param {*} inputArr input array, assumed csv
 * @returns an Object formatted with collapsing {ticker: {(ticker, string): {priceHistory: {(month, integer): {data...}}}}}. See comment below docket.
 */
/*
 * Ticker:
 *  ┕ priceHistory:
 *      ┝ 1: (month)
 *      .   ┝ open: price
 *      .   ┝ close: price
 *      .   ┕ ...
 *      ┝ 2:
 *      ┕ ...
 */
function convertData(inputArr) {
    let output = {};
    
    inputArr.forEach(item => {
        const {ticker, date, ...rest } = item;
        
        if (!output[ticker]) {
            output[ticker] = {
                priceHistory: {}
            };
        };
        
        
        output[ticker].priceHistory[date] = rest;
    });
    
    return output;
}

function genPriceTraceArray(tickerArr, dataPoint='close') {
    let traceList = [];

    //creating this variable to enforce the 5-trace maximum
    let tickerListTrunc = tickerArr.slice(0, 5);

    //iterate through ticker list
    for (let i=0; i < tickerListTrunc.length; i++) {
        //assign price history for ticker to variable
        let tickerData = organizedTickerData[tickerListTrunc[i]].priceHistory;
        let months = [];
        let prices = [];

        // Add months from tickerData to add both all available months 
        // and values for said months according to the specified dataPoint
        for(let key in tickerData) {
            months.push(key);
            prices.push(tickerData[key][`${dataPoint}`]);
        };

        // I'd like to make it so that a ticker remembers its color but
        // it should be fine just directly referencing the availableColors array for now
        let trace = {
            x: months,
            y: prices,
            mode: 'lines',
            name: tickerListTrunc[i],
            line: {color: availableColors[i]}
        };

        traceList.push(trace);
    };

    return traceList;
}

function mapValueToColor(value) {
    // Define the minimum and maximum values for mapping
    const minValue = -10;
    const maxValue = 10;
    
    // Map the value to a range between 0 and 1
    const mappedValue = (value - minValue) / (maxValue - minValue);

    // Define the hue for green (120 degrees) and red (0 degrees)
    const greenHue = 120;
    const redHue = 0;

    // Calculate the hue based on the mapped value
    let hue;
    if (mappedValue < 0.5) {
    // Interpolate hue between greenHue and 0 (yellow) for negative values
        hue = greenHue + (redHue - greenHue) * (mappedValue * 2);
    } else {
    // Interpolate hue between 0 (yellow) and redHue for positive values
        hue = redHue + (greenHue - redHue) * ((1 - mappedValue) * 2);
    }

    // Set saturation and lightness to a constant value
    const saturation = Math.abs(mappedValue) * 100;
    const lightness = 50;

    // Convert HSL to RGB
    const color = `hsl(${hue}, ${saturation}%, ${lightness}%)`;

    return color;
}

//generated by chatgpt for the genWordCloud() below
// Function to check if the first item is present
function isFirstItemPresent(array, target) {
    // Iterate over each inner array
    for (let innerArray of array) {
        // Check if the first item of the inner array matches the target
        if (innerArray[0] === target) {
            return array.indexOf(innerArray); // If found, return true
        }
    }
    return false; // If not found, return false
  }

function genWordCloud(tickerArr) {
    //creating this variable to enforce the 5-trace maximum
    //I'd like to make DRY code but I don't have time right now
    let tickerListTrunc = tickerArr.slice(0, 5);

    
    let finalWordArray = [];
    //iterate through ticker list
    for(let i=0; i < tickerListTrunc.length; i++) {
        let tickerWords = wordsAnalysisData[tickerListTrunc[i]][keywordSource].keywords.map(innerArray => {
            return innerArray.map(item => {
                // Scale the second item by whatever factor we decide on because I don't want to type it here twice constantly to make the commend match the code
                return (innerArray.indexOf(item) === 1) ? item * 2 : item;
            });
        });
        
        for(let j=0;j<tickerWords.length;j++) {
            let firstItemPres = isFirstItemPresent(finalWordArray, tickerWords[j][0]);
            if(firstItemPres != false) {
                // Add word values together if item is present in list and has returned an array index
                // (Added a size adjustment factor since it shows up more than once)
                finalWordArray[firstItemPres][tickerWords[j][0]].size += Math.abs(tickerWords[j][1]) * 2 + 50;

            } else {
                // Add word and value from tickerWords to list since it does not already exist
                finalWordArray.push({text: tickerWords[j][0], size: Math.sqrt(Math.abs(tickerWords[j][1]) * 250) + 15, colorValue: mapValueToColor(tickerWords[j][1] * 100)});
            }
        }   
    }

    console.log(finalWordArray);

    //refresh word cloud div so we get accurate sizes
    wordDiv = document.getElementById('word-cloud');

    //Delete existing svgs
    while (wordDiv.firstChild) {
        wordDiv.removeChild(wordDiv.firstChild);
    }

    cloudLayout = d3.layout.cloud()
        .size([wordDiv.clientWidth, wordDiv.clientHeight]) // Size of the word cloud area
        .words(finalWordArray)
        .padding(5)
        .rotate(function() { return ~~(Math.random() * 2) * 90; }) // Random rotation
        .font("Georgia")
        .fontSize(function(d) { return d.size; }) // Font size based on size attribute
        .on("end", draw);

    cloudLayout.start();

}

//updates active ticker list by querying the current list for selected tickers
function refreshTracesAndPlot(priceDataPoint='close', wordCloudDataSrc='news') {
    let oldTickerArr = currentTickerArr;
    let selectedTickerLiItems = document.querySelectorAll('li.selected');
    currentTickerArr = [];

    //check that the query selector did not return null
    if (selectedTickerLiItems){
        //iterate over tickers
        for (let i = 0;i < selectedTickerLiItems.length; i++){
            currentTickerArr.push(selectedTickerLiItems[i].textContent);
        }
    }

    //console.log(currentTickerArr);

    //only re-plot stocks if something actually changed
    if (oldTickerArr != currentTickerArr) {
        plotStocks(genPriceTraceArray(currentTickerArr));
        genWordCloud(currentTickerArr);
    }

}

export function clearSelectedStocks() {
    let selectedTickerLiItems = document.querySelectorAll('li.selected');
    selectedTickerLiItems.forEach(function(li) {
        li.classList.remove('selected');
    });
    numStocksSelected = 0;
    keywordList.classList.remove('full');
    refreshTracesAndPlot();
    
}

function resizePlot() {
    let update = {
        width: plotDiv.clientWidth,
        height: plotDiv.clientHeight
    };
    Plotly.relayout("price-plot", update);
    //cloudLayout.start();
}

// Callback function to draw the word cloud
function draw(words) {
    d3.select("#word-cloud").append("svg")
        .attr("width", wordDiv.clientWidth)
        .attr("height", wordDiv.clientHeight)
        .append("g")
        .attr("transform", "translate(" + cloudLayout.size()[0] / 2 + "," + cloudLayout.size()[1] / 2 + ")")
        .selectAll("text")
        .data(words)
        .enter().append("text")
        .style("font-size", function(d) { return d.size + "px"; })
        .style("font-family", "Georgia")
        .style("fill", function(d) { return d.colorValue; })
        .attr("text-anchor", "middle")
        .attr("transform", function(d) {
            return "translate(" + [d.x, d.y] + ")rotate(" + d.rotate + ")";
        })
        .text(function(d) { return d.text; });
}

/* --------------- *
 * EVENT LISTENERS
 * --------------- */

keywordInput.addEventListener('input', function() {
    let filter = keywordInput.value.trim().toLowerCase(); // trim() to remove leading/trailing spaces
    console.log(keywordItems);
    keywordItems.forEach(item => {
        let text = item.textContent.toLowerCase();
        if (text.includes(filter)) {
            item.style.display = 'block';
        } else {
            item.style.display = 'none';
        }
    });
});

// Event listener to handle keyword selection
keywordList.addEventListener('click', function(event) {
    if (event.target.classList.contains('keywordItem')) {
        const selectedKeyword = event.target.textContent;
        //console.log('Selected keyword:', selectedKeyword);

        //if it does NOT contain 'selected'
        if (!event.target.classList.contains('selected')) {
            if (numStocksSelected < 5) {
                // Add the 'selected' class to the clicked item
                event.target.classList.add('selected');
                numStocksSelected++;
            }
        } else {
            event.target.classList.remove('selected');
            numStocksSelected--;
        }

        if (numStocksSelected >= 5) {
            keywordList.classList.add('full');
        } else {
            keywordList.classList.remove('full');
        }

        refreshTracesAndPlot();
    }
});

//resize plot if window size changes
window.addEventListener('resize', resizePlot);

/* ------------------ *
 *   INITIALIZATION
 * ------------------ */

allTickers = Object.keys(organizedTickerData);

//add first ticker as a selected stock, set numStocksSelected to reflect
kwList.append("li").classed("keywordItem", true).classed("selected", true).text(allTickers[0]);
numStocksSelected = 1;
//adding the rest of our stock tickers
for(let i=1;i<allTickers.length;i++) {
    kwList.append("li").classed("keywordItem", true).classed("selected", false).text(allTickers[i]);
}
keywordItems = document.querySelectorAll('.keywordItem');

//-----------------------------------

let words = [
    {text: "Hello", size: 20},
    {text: "World", size: 40},
    {text: "Lorem", size: 30},
    // Add more words as needed
];

// Configure d3-cloud layout
let cloudLayout = d3.layout.cloud()
    .size([wordDiv.clientWidth, wordDiv.clientHeight]) // Size of the word cloud area
    .words(words)
    .padding(5)
    .rotate(function() { return ~~(Math.random() * 2) * 90; }) // Random rotation
    .font("Georgia")
    .fontSize(function(d) { return d.size; }) // Font size based on size attribute
    .on("end", draw); // Callback function to draw the cloud

// Generate the word cloud layout
cloudLayout.start();

refreshTracesAndPlot();

// grab stock data and process it
// EVERYTHING SHOULD BE IN THE SECOND .then() SO THAT IT GETS EXECUTED IN ORDER
fetch('Resourses/stockdata.csv')
    .then(response => response.text())
    .then(function(table) {
        
        //convert csv array to a more usable JavaScript Object
        //THE DATA WAS ORIGINALLY CLEANED UP HERE, BUT IT IS NO LONGER NECESSARY
        //JSON SAVED DIRECTLY TO priceData.js
        organizedTickerData = convertData(parsePriceCSV(table));

        allTickers = Object.keys(organizedTickerData);

        // console.log("tickers: ", tickers);
        // console.log(organizedTickerData);
        
        //assigning the keyword list
        let kwList = d3.select('#keywordList');
        
        //add first ticker as a selected stock, set numStocksSelected to reflect
        kwList.append("li").classed("keywordItem", true).classed("selected", true).text(allTickers[0]);
        numStocksSelected = 1;
        //adding the rest of our stock tickers
        for(let i=1;i<allTickers.length;i++) {
            kwList.append("li").classed("keywordItem", true).classed("selected", false).text(allTickers[i]);
        }
        
        keywordItems = document.querySelectorAll('.keywordItem');

        refreshTracesAndPlot();

    }).catch(err => console.log(err));

    
