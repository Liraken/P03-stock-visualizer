window.clearSelectedStocks = clearSelectedStocks;

// VARIABLES
// let parsedPriceData;
// let organizedTickerData; // This was moved to priceData.js
let allTickers;
let numStocksSelected = 0;
let availableColors = ['#0ae', '#f80', '#dd3', 'white', 'magenta'];
const keywordInput = document.getElementById('keywordInput');
const keywordList = document.getElementById('keywordList');
const radioButtons = document.querySelectorAll('input[type="radio"][name="kw-option"]');
//assigning the keyword list in d3 as well for the .append() function
let kwList = d3.select('#keywordList');
let keywordItems = document.querySelectorAll('.keywordItem');
let plotDiv = document.getElementById('price-plot');
let wordDiv = document.getElementById('word-cloud');
let currentTickerArr = [];

//this will be controllable via radio button to toggle between news and shareholder letters
let keywordSource = (document.getElementById('news').checked) ? 'news' : 'letterWords';
let lastPlottedKwSrc = keywordSource;
//console.log(keywordSource);



/* ------------- *
 *   FUNCTIONS
 * ------------- */

/**
 * _Code from user Bergi on StackOverflow_
 * _https://stackoverflow.com/questions/11786995/create-object-on-the-fly-from-csv_
 * @param {string} input string (raw CSV text)
 * @returns a 2-dimensional Array containing rows of CSV data.
 */
function parsePriceCSV(input) {
    let rows = input.split(/\r?\n/);
    let keys = rows.shift().split(",");
    return rows.map(function(row) {
        return row.split(",").reduce(function(oneRow, val, i) {
            oneRow[keys[i]] = val;
            return oneRow;
        }, {});
    });
}

// TODO ADD BUTTON TO REMOVE ALL SELECTED STOCKS

/**
 * _Generated by ChatGPT 3.5 and tweaked to our purposes._  
 * @param {Object[]} inputArr - input array, assumed parsed csv (2-d array output from parsePriceCSV() )
 * @returns an Object formatted with collapsing {ticker: {(ticker, string): {priceHistory: {(month, integer): {data...}}}}}. See comment below docket.
 */
/*
 * Ticker:
 *  ┕ priceHistory:
 *      ┝ 1: (month)
 *      .   ┝ open: price
 *      .   ┝ close: price
 *      .   ┕ ...
 *      ┝ 2:
 *      ┕ ...
 */
function convertData(inputArr) {
    let output = {};
    
    inputArr.forEach(item => {
        const {ticker, date, ...rest } = item;
        
        if (!output[ticker]) {
            output[ticker] = {
                priceHistory: {}
            };
        };
        
        
        output[ticker].priceHistory[date] = rest;
    });
    
    return output;
}

//  PRICE PLOT
// ------------

//generates array with traces for the Plotly plot
/**
 * _Written by Ashelyn Allred_  
 * @param {Object[]} inputArr - input array containing strings with ticker abbreviations (e.g. ["ORCL", "AMD"]).
 * @param {string} [dataPoint='close'] - what data point you want graphed from the priceHistory.
 * @returns an array of Plotly-ready traces using price data from the priceData Object.
 */
function genPriceTraceArray(tickerArr, dataPoint='close') {
    let traceArray = [];

    //creating this variable to enforce the 5-trace maximum
    let tickerListTrunc = tickerArr.slice(0, 5);

    //iterate through ticker list
    for (let i=0; i < tickerListTrunc.length; i++) {
        //assign price history for ticker to variable
        let tickerData = priceData[tickerListTrunc[i]].priceHistory;
        let months = [];
        let prices = [];

        // Add months from tickerData to add both all available months 
        // and values for said months according to the specified dataPoint
        for(let key in tickerData) {
            months.push(key);
            prices.push(tickerData[key][`${dataPoint}`]);
        };

        // I'd like to make it so that a ticker remembers its color but
        // it should be fine just directly referencing the available Colors array for now
        let trace = {
            x: months,
            y: prices,
            mode: 'lines',
            name: tickerListTrunc[i],
            line: {color: availableColors[i]}
        };

        traceArray.push(trace);
    };

    return traceArray;
}

//plot our stocks, input an array of traces
function plotStocks(traceArray) {
    //console.log(traceArray);

    let titleStr = '';
    if (traceArray.length > 0) {
        //preloading first ticker name into title string
        titleStr = `Stock Prices in $USD: ${traceArray[0].name}`;
        //iterating through rest of ticker names, adding them with comma separators
        for(let i = 1; i < traceArray.length; i++) {
            titleStr = titleStr + ", " + `${traceArray[i].name}`;
        };
    } else {
        titleStr = 'Select one or more stock tickers(s) to see plot!'
    }

    //console.log(titleStr);

    let layout = {
        dragmode: 'zoom',
        //selectdirection: 'h',
        title: titleStr,
        width: plotDiv.clientWidth,
        height: plotDiv.clientHeight,
        margin: {
            l: 30,
            r: 30,
            t: 90,
            b: 30
        },
        plot_bgcolor: '#111',
        paper_bgcolor: '#111',
        font: { color: '#eee' },
        line: { color: '#eee' },
        xaxis: { gridcolor: '#555' },
        yaxis: { gridcolor: '#555' }
    };

    Plotly.newPlot("price-plot", traceArray, layout);
}

//  WORD CLOUD
// ------------

// returns a color from green to gray to red, intended primarily for
// determining a word's color based on its WordValue for the word cloud
function mapValueToColor(wordValue) {
    // Define the minimum and maximum values for mapping
    const minValue = -10;
    const maxValue = 10;
    
    // Map the value to a range between 0 and 1
    const mappedValue = ((wordValue - minValue) / (maxValue - minValue) - 0.5) * 40;
    //console.log(value, mappedValue);

    // Define the hue for green (120 degrees) and red (0 degrees)
    const greenHue = 140;
    const redHue = 0;

    // Calculate the hue based on the mapped value
    // Green if above 0, red if below 0
    let hue = mappedValue > 0 ? greenHue : redHue;

    // Set saturation and lightness to a constant value
    const saturation = Math.pow(Math.abs(mappedValue), 2.4) * 12;
    const lightness = 50;

    const color = `hsl(${hue}, ${saturation}%, ${lightness}%)`;

    return color;
}

// generated by chatgpt for the genWordCloud() below
// Checks if the the first item of any child array within the `array` parameter is equal to the `target`
// Returns true if a match is found, false if it is not.
function isFirstItemPresent(array, target) {
    // Iterate over each inner array
    for (let innerArray of array) {
        // Check if the first item of the inner array matches the target
        if (innerArray[0] === target) {
            return array.indexOf(innerArray); // If found, return true
        }
    }
    return false; // If not found, return false
}

// clears out any existing children in the #word-cloud div so we can draw a new one in
// this exists because the d3-cloud library does not do that automatically
// and by default will add potentially limitless new svgs inside of the div, making it ridiculously large
// (there might be a way to change that behaviour, I haven't found it in the documentaiton though)
function clearCloud() {
    //refresh word cloud div so we get accurate sizes
    wordDiv = document.getElementById('word-cloud');

    //Delete existing svgs
    while (wordDiv.firstChild) {
        wordDiv.removeChild(wordDiv.firstChild);
    };
}

// create and draw word cloud
function genWordCloud(tickerArr) {
    // creating this variable to enforce the 5-trace maximum
    // I'd like to make DRY code but I don't have time right now 2024-01-05
    let tickerListTrunc = tickerArr.slice(0, 5);
    
    // creating an empty array to store our final word cloud
    let finalWordArray = [];

    let flatSizeAdj = (keywordSource === 'letterWords') ? 14 : 13;
    let expScaleAdj = (keywordSource === 'letterWords') ? 0.5 : 1.8;
    let multScaleAdj = (keywordSource === 'letterWords') ? 150 : 100;
    let colorScaleAdj = (keywordSource === 'letterWords') ? 300 : 1;

    // populate our words with logic to handle overlapping words
    // this is more nested for loops than I'm comfortable with, there's probably a much better way to do this
    // (probably with a modified data model because arrays in js are... not great. at least they're mutable though)
    // iterate through ticker list
    for(let i=0; i < tickerListTrunc.length; i++) {
        let tickerWords = wordsAnalysisData[tickerListTrunc[i]][keywordSource].keywords;
        // .map(innerArray => {
        //     return innerArray.map(item => {
        //         // Scale the second item by whatever factor we decide on because I don't want to type it here twice constantly to make the commend match the code
        //         return (innerArray.indexOf(item) === 1) ? item * 1 : item;
        //     });
        // });
        // // the map function above was used for some more direct scaling, but I don't think it's needed
        // // in favor of scaling it for size only in the for loop(s) below
        
        //console.log(tickerWords);
        for(let j=0;j<tickerWords.length;j++) {
            let firstItemPres = isFirstItemPresent(finalWordArray, tickerWords[j][0]);
            if(firstItemPres != false) {
                // Add word values together if item is present in list and has returned an array index
                // (Added a size adjustment factor since it shows up more than once)
                finalWordArray[firstItemPres][tickerWords[j][0]].size += Math.pow((Math.abs(tickerWords[j][1]), expScaleAdj));

            } else {
                // Add word and value from tickerWords to list since it does not already exist
                finalWordArray.push({
                    text: tickerWords[j][0], 
                    size: (Math.sqrt(Math.abs(tickerWords[j][1]) * multScaleAdj) + flatSizeAdj), 
                    colorValue: mapValueToColor(tickerWords[j][1] * colorScaleAdj)
                });
            }
        }   
    }

    //console.log(finalWordArray);

    // clear any existing word clouds if they exist to ready the canvas area
    clearCloud();

    // define our cloud parameters
    cloudLayout = d3.layout.cloud()
        .size([wordDiv.clientWidth, wordDiv.clientHeight]) // Size of the word cloud area
        .words(finalWordArray)
        .padding(3)
        .rotate(function() { return ~~(Math.random() * 2) * 90; }) // Random rotation
        .font("Georgia")
        .fontSize(function(d) { return d.size; }) // Font size based on size attribute
        .on("end", draw);

    // generate and draw the cloud!
    cloudLayout.start();

}

// Generated by ChatGPT
// Checks if two arrays contain the same items
// (so we don't redraw stuff unless we actually have to)
function arraysContainSameItems(arr1, arr2) {
    // Check if both arrays have the same length
    if (arr1.length !== arr2.length) {
        return false;
    }

    // Sort both arrays
    const sortedArr1 = arr1.slice().sort();
    const sortedArr2 = arr2.slice().sort();

    // Compare sorted arrays element by element
    for (let i = 0; i < sortedArr1.length; i++) {
        if (sortedArr1[i] !== sortedArr2[i]) {
            return false;
        }
    }

    // If all elements match, arrays contain the same items
    return true;
}

// Callback function to draw the word cloud
function draw(words) {
    d3.select("#word-cloud").append("svg")
        .attr("width", wordDiv.clientWidth)
        .attr("height", wordDiv.clientHeight)
        .append("g")
        .attr("transform", "translate(" + cloudLayout.size()[0] / 2 + "," + cloudLayout.size()[1] / 2 + ")")
        .selectAll("text")
        .data(words)
        .enter().append("text")
        .style("font-size", function(d) { return d.size + "px"; })
        .style("font-family", "Georgia")
        .style("fill", function(d) { return d.colorValue; })
        .attr("text-anchor", "middle")
        .attr("transform", function(d) {
            return "translate(" + [d.x, d.y] + ")rotate(" + d.rotate + ")";
        })
        .text(function(d) { return d.text; });
}

//  EVERYTHING
// ------------

//updates active ticker list by querying the current list for selected tickers
function refreshTracesAndPlot(priceDataPoint='close') {
    keywordItems = document.querySelectorAll('.keywordItem');
    let oldTickerArr = currentTickerArr;
    let selectedTickerLiItems = document.querySelectorAll('.selected');
    currentTickerArr = [];

    //check that the query selector did not return null
    if (selectedTickerLiItems){
        //iterate over tickers
        for (let i = 0;i < selectedTickerLiItems.length; i++){
            //check if the ticker can be found in the old ticker array
            //and only push our new item if it's not present
            currentTickerArr.push(selectedTickerLiItems[i].textContent);
        }
    }

    console.log(oldTickerArr);
    console.log(currentTickerArr);

    //only re-plot stocks if something actually changed
    if (!arraysContainSameItems(oldTickerArr, currentTickerArr) || keywordSource != lastPlottedKwSrc) {
        // console.log("different ticker arrays!");
        plotStocks(genPriceTraceArray(currentTickerArr, priceDataPoint));
        
        if (currentTickerArr.length > 0) {
            genWordCloud(currentTickerArr);
        } else {
            clearCloud();
            let promptWords = [
                {text: "Select", size: 48, colorValue: "#38c"},
                {text: "Stocks", size: 35, colorValue: "#38c"},
                {text: "to", size: 20, colorValue: "#26b"},
                {text: "the", size: 20, colorValue: "#26b"},
                {text: "Left", size: 56, colorValue: "#38c"},
            ];
            cloudLayout = d3.layout.cloud()
                .size([wordDiv.clientWidth, wordDiv.clientHeight]) // Size of the word cloud area
                .words(promptWords)
                .padding(5)
                .rotate(0) // Random rotation
                .font("Georgia")
                .fontSize(function(d) { return d.size; }) // Font size based on size attribute
                .on("end", draw);
            cloudLayout.start();
        };
    }
    lastPlottedKwSrc = keywordSource;
}

// clears out stocks and resets numStocksSelected so that new ones can be picked from the list
export function clearSelectedStocks() {
    let selectedTickerLiItems = document.querySelectorAll('li.selected');
    selectedTickerLiItems.forEach(function(li) {
        li.classList.remove('selected');
    });
    numStocksSelected = 0;
    keywordList.classList.remove('full');
    refreshTracesAndPlot();
}

// called on window size update by an Event Listener
function resizePlot() {
    let update = {
        width: plotDiv.clientWidth,
        height: plotDiv.clientHeight
    };
    Plotly.relayout("price-plot", update);
    //clearCloud();
    cloudLayout.size([wordDiv.clientWidth, wordDiv.clientHeight]);
}

// go through all keywordItems and hide whatever doesn't have the class contained in classFilter present
// also deselect it and decrement numStocksSelected if a selected stock doesn't have that same class
function evalValidStocksFromKeywordSrc(classFilter) {
    keywordItems.forEach(item => {
        if (item.classList.contains(classFilter)) {
            item.style.display = 'block';
        } else {
            item.style.display = 'none';

            // I don't like running this check every time, but it's the easiest way I can think of
            // to make sure we're properly controlling numStocksSelected at the same time.
            if (item.classList.contains('selected')) {
                item.classList.remove('selected');
                numStocksSelected--;
            }
        }
    });
}

/* --------------- *
 * EVENT LISTENERS
 * --------------- */

//ticker search box
keywordInput.addEventListener('input', function() {
    let filter = keywordInput.value.trim().toLowerCase(); // trim() to remove leading/trailing spaces
    //console.log(keywordItems);
    keywordItems.forEach(item => {
        let text = item.textContent.toLowerCase();
        if (text.includes(filter)) {
            item.style.display = 'block';
        } else {
            item.style.display = 'none';
        }
    });
});

// handle keyword selection by user, enforce 5 keyword limit
keywordList.addEventListener('click', function(event) {
    if (event.target.classList.contains('keywordItem')) {
        const selectedKeyword = event.target.textContent;
        //console.log('Selected keyword:', selectedKeyword);

        //if it does NOT contain 'selected'
        if (!event.target.classList.contains('selected')) {
            if (numStocksSelected < 5) {
                // Add the 'selected' class to the clicked item
                event.target.classList.add('selected');
                numStocksSelected++;
            }
        } else {
            event.target.classList.remove('selected');
            numStocksSelected--;
            // WE DO NOT NEED TO UPDATE THE TICKER ARRAY HERE, that is done automatically by refreshTracesAndPlot();
        }

        if (numStocksSelected >= 5) {
            keywordList.classList.add('full');
        } else {
            keywordList.classList.remove('full');
        }

        refreshTracesAndPlot();
    }
});

// resize plots if window size changes
window.addEventListener('resize', resizePlot);

// radio buttons
radioButtons.forEach(radioButton => {
    radioButton.addEventListener('change', function() {

        keywordSource = this.value;
        let classFilter = (this.value === 'letterWords') ? 'has-letter' : 'has-news';
        //console.log(keywordSource, classFilter);

        evalValidStocksFromKeywordSrc(classFilter);

        if (numStocksSelected < 5) {
            keywordList.classList.remove('full');
        };

        refreshTracesAndPlot();
    });
});

/* ------------------ *
 *   INITIALIZATION
 * ------------------ */

allTickers = Object.keys(priceData);

//adding the rest of our stock tickers
for(let i=0;i<allTickers.length;i++) {
    kwList.append("li").classed("keywordItem", true)
        .classed("selected", false)
        .classed("has-letter", priceData[allTickers[i]].hasLetter)
        .classed("has-news", priceData[allTickers[i]].hasNews)
        .text(allTickers[i]);
}

// refresh the keywordItems
keywordItems = document.querySelectorAll('.keywordItem');

// I really need to turn this ternary operator into its own function
evalValidStocksFromKeywordSrc(keywordSource === 'letterWords' ? 'has-letter' : 'has-news');

// find first stock with current keywordSource selection and select it
let firstWithKwClass = document.querySelector(`.keywordItem.${(keywordSource === 'letterWords' ? 'has-letter' : 'has-news')}`);
console.log(firstWithKwClass);
firstWithKwClass.classList.add('selected')
numStocksSelected += 1;

// console.log(wordsAnalysisData);


// INIT: CONFIGURE WORDCLOUD
//---------------------------

let defaultWords = [
    {text: "Hello", size: 20},
    {text: "World", size: 40},
    {text: "Lorem", size: 30},
];

// Configure d3-cloud layout
let cloudLayout = d3.layout.cloud()
    .size([wordDiv.clientWidth, wordDiv.clientHeight]) // Size of the word cloud area
    .words(defaultWords)
    .padding(5)
    .rotate(function() { return ~~(Math.random() * 2) * 90; }) // Random rotation
    .font("Georgia")
    .fontSize(function(d) { return d.size; }) // Font size based on size attribute
    .on("end", draw); // Callback function to draw the cloud

// Generate the word cloud layout
cloudLayout.start();


// INIT: SEND PLOTS TO SCREEN
//----------------------------

refreshTracesAndPlot();



/* ------------------ *
 *   DATA WRANGLING
 * ------------------ * 
 * 
 * Everything below here was used temporarily to modify our data until it was in a satisfactory state.
 *  
 * */


// // I wrote this in the console and in this file until the json looked right
// // It adds a key hasLetter that corresponds to a non-null count which is now substituted for our main json -Ashe
// let neededOutput = organizedTickerData;
// for (let key in neededOutput) {
//     if (wordsAnalysisData[key]) {
//         neededOutput[key].hasLetter =  wordsAnalysisData[key].letterWords.totalWordCount === null ? false : true;
//         neededOutput[key].hasNews =  wordsAnalysisData[key].news.totalWordCount === null ? false : true;
//     } else {
//         neededOutput[key].hasLetter = false
//         neededOutput[key].hasNews = false
//     }};

// console.log(neededOutput);


// // grab stock data and process it
// // EVERYTHING SHOULD BE IN THE SECOND .then() SO THAT IT GETS EXECUTED IN ORDER
// fetch('Resourses/stockdata.csv')
//     .then(response => response.text())
//     .then(function(table) {
        
//         //convert csv array to a more usable JavaScript Object
//         //THE DATA WAS ORIGINALLY CLEANED UP HERE, BUT IT IS NO LONGER NECESSARY
//         //JSON SAVED DIRECTLY TO priceData.js
//         organizedTickerData = convertData(parsePriceCSV(table));

//         allTickers = Object.keys(organizedTickerData);

//         // console.log("tickers: ", tickers);
//         // console.log(organizedTickerData);
        
//         //assigning the keyword list
//         let kwList = d3.select('#keywordList');
        
//         //add first ticker as a selected stock, set numStocksSelected to reflect
//         kwList.append("li").classed("keywordItem", true).classed("selected", true).text(allTickers[0]);
//         numStocksSelected = 1;
//         //adding the rest of our stock tickers
//         for(let i=1;i<allTickers.length;i++) {
//             kwList.append("li").classed("keywordItem", true).classed("selected", false).text(allTickers[i]);
//         }
        
//         keywordItems = document.querySelectorAll('.keywordItem');

//         refreshTracesAndPlot();

//     }).catch(err => console.log(err));